#!/usr/bin/expect -f
#
# FerrumPy REPL Integration Test - Simplified
#
# Tests basic REPL functionality

set timeout 300
set project_root [lindex $argv 0]

# Disable terminal formatting to avoid ANSI escape sequence issues
set env(TERM) dumb
# Force simple REPL mode (no prompt_toolkit) for testing
set env(FERRUMPY_SIMPLE_MODE) 1

# Start LLDB
spawn lldb $project_root/tests/rust_sample/target/debug/rust_sample

# Load ferrumpy
expect "(lldb)"
send "command script import $project_root/python/ferrumpy\r"

# Set breakpoint
expect "loaded"
send "b main.rs:94\r"

# Run
expect "Breakpoint"
send "run\r"

# Wait for breakpoint hit and lldb prompt
expect "stop reason = breakpoint"
expect "(lldb)"

# Start REPL
send "ferrumpy repl\r"

# Wait for REPL prompt (>> ) - this may take time for compilation
expect {
    ">>" {
        puts "\n✓ REPL initialized and prompt ready"
    }
    timeout {
        puts "\n✗ Timeout waiting for REPL prompt"
        exit 1
    }
}

# Test 1: Basic expression evaluation
send "let x = 42;\r"
expect ">>"

send "x + 1\r"
expect {
    "43" {
        puts "✓ Basic expression evaluation works"
    }
    timeout {
        puts "\n✗ Basic expression evaluation failed"
        exit 1
    }
}

# Test 2: String manipulation
expect ">>"
send "\"hello\".to_uppercase()\r"
expect {
    "HELLO" {
        puts "✓ String method works"
    }
    timeout {
        puts "\n⚠ String method timeout (may be acceptable)"
    }
}

# ========================================
# Test 3: Snapshot Variable Access Tests
# ========================================
# These test that captured variables from the debugged process are accessible

# Test 3a: Access simple_string (String type)
expect ">>"
send "simple_string.clone()\r"
expect {
    "Hello" {
        puts "✓ Snapshot variable 'simple_string' accessible"
    }
    "error" {
        puts "\n✗ FAILED: Cannot access snapshot variable 'simple_string'"
        exit 1
    }
    timeout {
        puts "\n✗ Timeout accessing 'simple_string'"
        exit 1
    }
}

# Test 3b: Access numbers (Vec<i32>)
expect ">>"
send "numbers.len()\r"
expect {
    "5" {
        puts "✓ Snapshot variable 'numbers' accessible (len=5)"
    }
    "error" {
        puts "\n✗ FAILED: Cannot access snapshot variable 'numbers'"
        exit 1
    }
    timeout {
        puts "\n✗ Timeout accessing 'numbers'"
        exit 1
    }
}

# Test 3c: Access ok_result (Result<i32, String> or serde_json::Value)
expect ">>"
send "ok_result\r"
expect {
    -re "Ok|Err|Object|Number|String|Null|Array" {
        puts "✓ Snapshot variable 'ok_result' accessible"
    }
    "cannot find" {
        puts "\n✗ FAILED: Cannot access snapshot variable 'ok_result'"
        exit 1
    }
    timeout {
        puts "\n✗ Timeout accessing 'ok_result'"
        exit 1
    }
}

# Test 3d: Access map (HashMap<String, i32> or serde_json::Value)
expect ">>"
send "map\r"
expect {
    -re "Object|Number|String|Null|Array" {
        puts "✓ Snapshot variable 'map' accessible"
    }
    "cannot find" {
        puts "\n✗ FAILED: Cannot access snapshot variable 'map'"
        exit 1
    }
    timeout {
        puts "\n✗ Timeout accessing 'map'"
        exit 1
    }
}

# ========================================
# Test 4: Function Definition and Execution
# ========================================

# Test 4a: Define and call a simple function
expect ">>"
send "fn add(a: i32, b: i32) -> i32 { a + b }\r"
expect ">>"
send "add(10, 20)\r"
expect {
    "30" {
        puts "✓ Function definition and call works"
    }
    "error" {
        puts "\n✗ FAILED: Function definition/call failed"
        exit 1
    }
    timeout {
        puts "\n✗ Timeout on function test"
        exit 1
    }
}

# Note: Test 4b (function using snapshot variables) was removed.
# evcxr's let bindings are local and cannot be accessed from user-defined functions.
# This is a known limitation - use closure captures or pass variables as parameters.

# Test 4b: Define and call a recursive function
expect ">>"
send "fn fib(n: u32) -> u32 { if n <= 1 { n } else { fib(n-1) + fib(n-2) } }\r"
expect ">>"
send "fib(10)\r"
expect {
    "55" {
        puts "✓ Recursive function works"
    }
    timeout {
        puts "\n⚠ Recursive function timeout (may be acceptable)"
    }
}

# ========================================
# Test 5: Loop Constructs
# ========================================

# Test 5a: For loop with range
expect ">>"
send "let mut sum = 0; for i in 0..5 { sum += i; } sum\r"
expect {
    "10" {
        puts "✓ For loop with range works"
    }
    "error" {
        puts "\n✗ FAILED: For loop failed"
        exit 1
    }
    timeout {
        puts "\n✗ Timeout on for loop test"
        exit 1
    }
}

# Test 5b: While loop
expect ">>"
send "let mut n = 0; while n < 3 { n += 1; } n\r"
expect {
    "3" {
        puts "✓ While loop works"
    }
    timeout {
        puts "\n⚠ While loop timeout (may be acceptable)"
    }
}

# Test 5c: Loop with break
expect ">>"
send "let mut count = 0; loop { count += 1; if count >= 4 { break; } } count\r"
expect {
    "4" {
        puts "✓ Loop with break works"
    }
    timeout {
        puts "\n⚠ Loop with break timeout (may be acceptable)"
    }
}

# ========================================
# Test 6: Closures
# ========================================

# Test 6a: Immediately invoked closure (wrapped in braces to prevent variable persistence)
expect ">>"
send "{ let square = |x: i32| x * x; square(7) }\r"
expect {
    "49" {
        puts "✓ Simple closure works"
    }
    timeout {
        puts "\n⚠ Closure timeout (may be acceptable)"
    }
}

# Test 6b: Closure with captured variable (wrapped in braces)
expect ">>"
send "{ let factor = 3; let multiply = |x: i32| x * factor; multiply(5) }\r"
expect {
    "15" {
        puts "✓ Closure with capture works"
    }
    timeout {
        puts "\n⚠ Closure with capture timeout (may be acceptable)"
    }
}

# ========================================
# Test 7: Iterators and Functional Programming
# ========================================

# Test 7a: Map and collect (using braces wrap to avoid Tcl interpretation)
expect ">>"
send {let v: Vec<i32> = vec![1, 2, 3].iter().map(|x| x * 2).collect(); v}
send "\r"
expect {
    -re {Vec|\[2} {
        puts "✓ Iterator map/collect works"
    }
    timeout {
        puts "\n⚠ Iterator timeout (may be acceptable)"
    }
}

# Test 7b: Filter
expect ">>"
send "let evens: Vec<i32> = (1..6).filter(|x| x % 2 == 0).collect(); evens.len()\r"
expect {
    "2" {
        puts "✓ Iterator filter works"
    }
    timeout {
        puts "\n⚠ Filter timeout (may be acceptable)"
    }
}

# Test 7c: Fold/reduce (using braces wrap)
expect ">>"
send {(1..=5).fold(0, |acc, x| acc + x)}
send "\r"
expect {
    "15" {
        puts "✓ Iterator fold works"
    }
    timeout {
        puts "\n⚠ Fold timeout (may be acceptable)"
    }
}

# ========================================
# Test 8: Pattern Matching
# ========================================

# Test 8a: Match expression
expect ">>"
send "let val = 2; match val { 1 => \"one\", 2 => \"two\", _ => \"other\" }\r"
expect {
    "two" {
        puts "✓ Match expression works"
    }
    timeout {
        puts "\n⚠ Match timeout (may be acceptable)"
    }
}

# Test 8b: If-let pattern
expect ">>"
send "let opt = Some(42); if let Some(v) = opt { v } else { 0 }\r"
expect {
    "42" {
        puts "✓ If-let pattern works"
    }
    timeout {
        puts "\n⚠ If-let timeout (may be acceptable)"
    }
}

# ========================================
# Test 9: Struct Definition and Usage
# ========================================

# Test 9a: Define and instantiate a struct
expect ">>"
send "struct Point { x: i32, y: i32 }\r"
expect ">>"
send "let p = Point { x: 10, y: 20 }; p.x + p.y\r"
expect {
    "30" {
        puts "✓ Struct definition and usage works"
    }
    timeout {
        puts "\n⚠ Struct timeout (may be acceptable)"
    }
}

# Test 9b: Struct with impl block
expect ">>"
send "impl Point { fn distance_from_origin(&self) -> f64 { ((self.x.pow(2) + self.y.pow(2)) as f64).sqrt() } }\r"
expect ">>"
send "let p2 = Point { x: 3, y: 4 }; p2.distance_from_origin()\r"
expect {
    "5" {
        puts "✓ Struct with impl block works"
    }
    timeout {
        puts "\n⚠ Struct impl timeout (may be acceptable)"
    }
}

# ========================================
# Test 10: Vec Operations on Snapshot Data
# ========================================

# Test 10a: Iterate over snapshot numbers
expect ">>"
send "let doubled: Vec<i32> = numbers.iter().map(|x| x * 2).collect(); doubled.len()\r"
expect {
    "5" {
        puts "✓ Vec operations on snapshot data works"
    }
    timeout {
        puts "\n⚠ Vec operations timeout (may be acceptable)"
    }
}

# Test 10b: Sum of numbers
expect ">>"
send "numbers.iter().sum::<i32>()\r"
expect {
    "15" {
        puts "✓ Sum of snapshot numbers works"
    }
    timeout {
        puts "\n⚠ Sum timeout (may be acceptable)"
    }
}

# ========================================
# Test 11: Complex Expressions
# ========================================

# Test 11a: String formatting and manipulation
expect ">>"
send "let name = \"Rust\"; format!(\"Hello, {}!\", name)\r"
expect {
    "Hello, Rust!" {
        puts "✓ String formatting works"
    }
    timeout {
        puts "\n⚠ String formatting timeout (may be acceptable)"
    }
}

# Exit REPL
expect ">>"
send ":q\r"

expect {
    -re "(REPL session ended|lldb)" {
        puts "✓ REPL exit successful"
    }
    timeout {
        puts "\n⚠ Timeout on REPL exit (may be acceptable)"
    }
}

# Clean up
expect "(lldb)"
send "kill\r"
expect "(lldb)"
send "quit\r"

puts "\n=== REPL Integration Test PASSED ==="
exit 0
